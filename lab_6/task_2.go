package main

//2. Реализуйте приложение, в котором одна горутина генерирует последовательность чисел и отправляет их в канал.
//Другая горутина должна считывать данные из канала и выводить их на экран.
//Добавьте блокировку чтения из канала с помощью close() и объясните её роль.

//канал приостанавливает (блокирует) горутину до тех пор пока из о него не извлечется значение и соотв. в него это значение не поместят
//или до тек пор пока канал не закроется
//close() закрывает канал, тем самым прекращая ожидание данных в print(), что позволяет print() продолжить работу (и завершиться)

import (
	"fmt"
	"time"
)

func task_2() {
	var ch chan int = make(chan int)

	go func() {
		fmt.Println("Генерирую")
		for i := range 10 {
			ch <- i * i
		}
		close(ch)
	}()

	go func() {
		fmt.Println("Принтую")
		for n := range ch { //цикл работает до закрытия канала, итерация при новом n (т.к. <-ch прерывает работу горутины)
			fmt.Println(n)
		}
	}()
	time.Sleep(1 * time.Second)
	fmt.Println("Конец выполнения 2 задания")
}
